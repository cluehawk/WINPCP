Here’s the **“known-good / verified-working”** picture of the **Plantronics ColorPlus modes** from the API work, focusing on **mode setup + VRAM layout + address math**.

---

## Verified working modes

### 1) 320×200×16 (Plantronics “ColorPlus 16-color”)

**How it’s entered**

* Set **BIOS mode 5** (320×200 4-color) first.
* Enable ColorPlus extensions by writing **AL=$10 to port $3DD**. 

**VRAM organization (this is the key)**

* VRAM is in **segment $B800**.
* It behaves like **two “pages/planes” stacked in the same segment**:

  * **Page 0 @ B800:0000** = **Red/Green (RG)** data
  * **Page 1 @ B800:4000** (i.e., **+16384**) = **Blue/Intensity (BI)** data 
* Each scanline is **80 bytes wide** in each page (because 320 pixels ÷ 4 pixels/byte = 80). 

**Pixel packing (320 mode)**

* Each pixel is **4 bits total**, split as **2 bits in RG page + 2 bits in BI page** (so you write *both* pages for a single pixel).
* Byte selection for X:

  * `byteX := x shr 2` (x / 4)
* Within-byte bit position (the “we finally fixed diagonals” bit):

  * `bitOfs := (3 - (x and 3)) shl 1`  (2 bits per pixel, MS pixel first) 

**Scanline interleaving (CGA-style even/odd)**

* Scanlines are interleaved in 8 KB banks (classic CGA behavior), and the driver’s update loop matches what we validated:

  * After finishing a scanline: `ofs += 8192`
  * If that crosses the 16 KB page boundary, wrap back with `ofs -= 16304` (this is the practical “next line” wrap constant used in working code). 
    In other words: you don’t compute `y*80` linearly; you step through the CGA interleave.

**Writing a pixel/byte**

* Compute the destination offset for (x,y) in **CGA interleaved space**, then:

  * Write RG byte at `B800:ofs`
  * Write BI byte at `B800:(ofs + 16384)` 

---

### 2) 640×200×4 (Plantronics “ColorPlus 4-color at 640”)

This mode exists in the API’s mode set (and was treated as a first-class supported mode alongside 320×200×16). 

**What we considered “verified” from the project side**

* It is handled as a distinct Plantronics mode (not “plain CGA 640×200×2”), i.e., the API treats it as a working target mode with Plantronics-aware addressing/bit math. 

**Memory handling model we used (consistent with the working 320×200×16 handling)**

* Same **CGA scanline interleaving concept** (even/odd scanlines split by +8192).
* Same concept of **multiple bitplanes/pages** in **B800h**, where you combine planes to form the final color index (the exact per-plane packing differs from 320 mode because 640 implies different pixels/byte).

> If you want, I can write the exact “known-good” 640×200×4 offset/bit macros in the same style as the final 320×200×16 ones (byte offset + bit position + page selection). The two things I’d anchor them to are the **final PLN byte/bit helpers** you ended up with in the API (the ones referenced by the rules doc) plus whichever 640×200×4 memory write routine you last had working.

---

## “Do this, not that” summary (what we validated in practice)

* **Always treat Plantronics 320×200×16 as two pages in B800:** base + **+16384**. 
* **Don’t linearize Y**. Use the **CGA interleave stepping** (the working code literally does `+8192` and wraps). 
* For 320×200×16 **bit placement**, the correct within-byte pixel ordering is:

  * `bitOfs := (3 - (x and 3)) shl 1` 

If you paste (or point me at) the **final PLN_GFX unit** you were using when you declared both modes “working”, I can turn this into a **tight, implementation-ready spec** (exact formulas for both modes, including the 640×200×4 plane packing) in the same style as your project handoff notes.
